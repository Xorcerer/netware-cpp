// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: player.proto

#ifndef PROTOBUF_player_2eproto__INCLUDED
#define PROTOBUF_player_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace camp {
namespace protocols {
namespace player {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_player_2eproto();
void protobuf_AssignDesc_player_2eproto();
void protobuf_ShutdownFile_player_2eproto();

class HandShakingReq;
class HandShakingAck;
class LoginOrCreateAccountReq;
class LoginOrCreateAccountAck;

enum HandShakingAck_AckError {
  HandShakingAck_AckError_NO_ERROR = 0,
  HandShakingAck_AckError_CLIENT_UPDATE_REQUIRED = 1,
  HandShakingAck_AckError_INVALID_SESSION_KEY = 2
};
bool HandShakingAck_AckError_IsValid(int value);
const HandShakingAck_AckError HandShakingAck_AckError_AckError_MIN = HandShakingAck_AckError_NO_ERROR;
const HandShakingAck_AckError HandShakingAck_AckError_AckError_MAX = HandShakingAck_AckError_INVALID_SESSION_KEY;
const int HandShakingAck_AckError_AckError_ARRAYSIZE = HandShakingAck_AckError_AckError_MAX + 1;

enum LoginOrCreateAccountAck_AckError {
  LoginOrCreateAccountAck_AckError_NO_ERROR = 0,
  LoginOrCreateAccountAck_AckError_INVALID_AUTH_TOKEN = 1
};
bool LoginOrCreateAccountAck_AckError_IsValid(int value);
const LoginOrCreateAccountAck_AckError LoginOrCreateAccountAck_AckError_AckError_MIN = LoginOrCreateAccountAck_AckError_NO_ERROR;
const LoginOrCreateAccountAck_AckError LoginOrCreateAccountAck_AckError_AckError_MAX = LoginOrCreateAccountAck_AckError_INVALID_AUTH_TOKEN;
const int LoginOrCreateAccountAck_AckError_AckError_ARRAYSIZE = LoginOrCreateAccountAck_AckError_AckError_MAX + 1;

// ===================================================================

class HandShakingReq : public ::google::protobuf::MessageLite {
 public:
  HandShakingReq();
  virtual ~HandShakingReq();

  HandShakingReq(const HandShakingReq& from);

  inline HandShakingReq& operator=(const HandShakingReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const HandShakingReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HandShakingReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HandShakingReq* other);

  // implements Message ----------------------------------------------

  HandShakingReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HandShakingReq& from);
  void MergeFrom(const HandShakingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_version = 1;
  inline bool has_client_version() const;
  inline void clear_client_version();
  static const int kClientVersionFieldNumber = 1;
  inline const ::std::string& client_version() const;
  inline void set_client_version(const ::std::string& value);
  inline void set_client_version(const char* value);
  inline void set_client_version(const char* value, size_t size);
  inline ::std::string* mutable_client_version();
  inline ::std::string* release_client_version();
  inline void set_allocated_client_version(::std::string* client_version);

  // optional string session_key = 2;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 2;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // @@protoc_insertion_point(class_scope:camp.protocols.player.HandShakingReq)
 private:
  inline void set_has_client_version();
  inline void clear_has_client_version();
  inline void set_has_session_key();
  inline void clear_has_session_key();

  ::std::string* client_version_;
  ::std::string* session_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static HandShakingReq* default_instance_;
};
// -------------------------------------------------------------------

class HandShakingAck : public ::google::protobuf::MessageLite {
 public:
  HandShakingAck();
  virtual ~HandShakingAck();

  HandShakingAck(const HandShakingAck& from);

  inline HandShakingAck& operator=(const HandShakingAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const HandShakingAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HandShakingAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HandShakingAck* other);

  // implements Message ----------------------------------------------

  HandShakingAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HandShakingAck& from);
  void MergeFrom(const HandShakingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HandShakingAck_AckError AckError;
  static const AckError NO_ERROR = HandShakingAck_AckError_NO_ERROR;
  static const AckError CLIENT_UPDATE_REQUIRED = HandShakingAck_AckError_CLIENT_UPDATE_REQUIRED;
  static const AckError INVALID_SESSION_KEY = HandShakingAck_AckError_INVALID_SESSION_KEY;
  static inline bool AckError_IsValid(int value) {
    return HandShakingAck_AckError_IsValid(value);
  }
  static const AckError AckError_MIN =
    HandShakingAck_AckError_AckError_MIN;
  static const AckError AckError_MAX =
    HandShakingAck_AckError_AckError_MAX;
  static const int AckError_ARRAYSIZE =
    HandShakingAck_AckError_AckError_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .camp.protocols.player.HandShakingAck.AckError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::camp::protocols::player::HandShakingAck_AckError error() const;
  inline void set_error(::camp::protocols::player::HandShakingAck_AckError value);

  // optional string salt = 2;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 2;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const char* value, size_t size);
  inline ::std::string* mutable_salt();
  inline ::std::string* release_salt();
  inline void set_allocated_salt(::std::string* salt);

  // optional .camp.protocols.common.Endpoint redirect_to = 3;
  inline bool has_redirect_to() const;
  inline void clear_redirect_to();
  static const int kRedirectToFieldNumber = 3;
  inline const ::camp::protocols::common::Endpoint& redirect_to() const;
  inline ::camp::protocols::common::Endpoint* mutable_redirect_to();
  inline ::camp::protocols::common::Endpoint* release_redirect_to();
  inline void set_allocated_redirect_to(::camp::protocols::common::Endpoint* redirect_to);

  // @@protoc_insertion_point(class_scope:camp.protocols.player.HandShakingAck)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_salt();
  inline void clear_has_salt();
  inline void set_has_redirect_to();
  inline void clear_has_redirect_to();

  ::std::string* salt_;
  ::camp::protocols::common::Endpoint* redirect_to_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static HandShakingAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginOrCreateAccountReq : public ::google::protobuf::MessageLite {
 public:
  LoginOrCreateAccountReq();
  virtual ~LoginOrCreateAccountReq();

  LoginOrCreateAccountReq(const LoginOrCreateAccountReq& from);

  inline LoginOrCreateAccountReq& operator=(const LoginOrCreateAccountReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginOrCreateAccountReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginOrCreateAccountReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginOrCreateAccountReq* other);

  // implements Message ----------------------------------------------

  LoginOrCreateAccountReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginOrCreateAccountReq& from);
  void MergeFrom(const LoginOrCreateAccountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string auth_token = 1;
  inline bool has_auth_token() const;
  inline void clear_auth_token();
  static const int kAuthTokenFieldNumber = 1;
  inline const ::std::string& auth_token() const;
  inline void set_auth_token(const ::std::string& value);
  inline void set_auth_token(const char* value);
  inline void set_auth_token(const char* value, size_t size);
  inline ::std::string* mutable_auth_token();
  inline ::std::string* release_auth_token();
  inline void set_allocated_auth_token(::std::string* auth_token);

  // @@protoc_insertion_point(class_scope:camp.protocols.player.LoginOrCreateAccountReq)
 private:
  inline void set_has_auth_token();
  inline void clear_has_auth_token();

  ::std::string* auth_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static LoginOrCreateAccountReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginOrCreateAccountAck : public ::google::protobuf::MessageLite {
 public:
  LoginOrCreateAccountAck();
  virtual ~LoginOrCreateAccountAck();

  LoginOrCreateAccountAck(const LoginOrCreateAccountAck& from);

  inline LoginOrCreateAccountAck& operator=(const LoginOrCreateAccountAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginOrCreateAccountAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginOrCreateAccountAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginOrCreateAccountAck* other);

  // implements Message ----------------------------------------------

  LoginOrCreateAccountAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginOrCreateAccountAck& from);
  void MergeFrom(const LoginOrCreateAccountAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoginOrCreateAccountAck_AckError AckError;
  static const AckError NO_ERROR = LoginOrCreateAccountAck_AckError_NO_ERROR;
  static const AckError INVALID_AUTH_TOKEN = LoginOrCreateAccountAck_AckError_INVALID_AUTH_TOKEN;
  static inline bool AckError_IsValid(int value) {
    return LoginOrCreateAccountAck_AckError_IsValid(value);
  }
  static const AckError AckError_MIN =
    LoginOrCreateAccountAck_AckError_AckError_MIN;
  static const AckError AckError_MAX =
    LoginOrCreateAccountAck_AckError_AckError_MAX;
  static const int AckError_ARRAYSIZE =
    LoginOrCreateAccountAck_AckError_AckError_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .camp.protocols.player.LoginOrCreateAccountAck.AckError error = 1 [default = NO_ERROR];
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::camp::protocols::player::LoginOrCreateAccountAck_AckError error() const;
  inline void set_error(::camp::protocols::player::LoginOrCreateAccountAck_AckError value);

  // optional string session_key = 2;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 2;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // @@protoc_insertion_point(class_scope:camp.protocols.player.LoginOrCreateAccountAck)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_session_key();
  inline void clear_has_session_key();

  ::std::string* session_key_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_player_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_player_2eproto();
  #endif
  friend void protobuf_AssignDesc_player_2eproto();
  friend void protobuf_ShutdownFile_player_2eproto();

  void InitAsDefaultInstance();
  static LoginOrCreateAccountAck* default_instance_;
};
// ===================================================================


// ===================================================================

// HandShakingReq

// required string client_version = 1;
inline bool HandShakingReq::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandShakingReq::set_has_client_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandShakingReq::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandShakingReq::clear_client_version() {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    client_version_->clear();
  }
  clear_has_client_version();
}
inline const ::std::string& HandShakingReq::client_version() const {
  return *client_version_;
}
inline void HandShakingReq::set_client_version(const ::std::string& value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void HandShakingReq::set_client_version(const char* value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void HandShakingReq::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandShakingReq::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  return client_version_;
}
inline ::std::string* HandShakingReq::release_client_version() {
  clear_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_version_;
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandShakingReq::set_allocated_client_version(::std::string* client_version) {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    delete client_version_;
  }
  if (client_version) {
    set_has_client_version();
    client_version_ = client_version;
  } else {
    clear_has_client_version();
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string session_key = 2;
inline bool HandShakingReq::has_session_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandShakingReq::set_has_session_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandShakingReq::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandShakingReq::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& HandShakingReq::session_key() const {
  return *session_key_;
}
inline void HandShakingReq::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void HandShakingReq::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void HandShakingReq::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandShakingReq::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* HandShakingReq::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandShakingReq::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HandShakingAck

// optional .camp.protocols.player.HandShakingAck.AckError error = 1;
inline bool HandShakingAck::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandShakingAck::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandShakingAck::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandShakingAck::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::camp::protocols::player::HandShakingAck_AckError HandShakingAck::error() const {
  return static_cast< ::camp::protocols::player::HandShakingAck_AckError >(error_);
}
inline void HandShakingAck::set_error(::camp::protocols::player::HandShakingAck_AckError value) {
  assert(::camp::protocols::player::HandShakingAck_AckError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional string salt = 2;
inline bool HandShakingAck::has_salt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandShakingAck::set_has_salt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandShakingAck::clear_has_salt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandShakingAck::clear_salt() {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    salt_->clear();
  }
  clear_has_salt();
}
inline const ::std::string& HandShakingAck::salt() const {
  return *salt_;
}
inline void HandShakingAck::set_salt(const ::std::string& value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void HandShakingAck::set_salt(const char* value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void HandShakingAck::set_salt(const char* value, size_t size) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandShakingAck::mutable_salt() {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  return salt_;
}
inline ::std::string* HandShakingAck::release_salt() {
  clear_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = salt_;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HandShakingAck::set_allocated_salt(::std::string* salt) {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    delete salt_;
  }
  if (salt) {
    set_has_salt();
    salt_ = salt;
  } else {
    clear_has_salt();
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .camp.protocols.common.Endpoint redirect_to = 3;
inline bool HandShakingAck::has_redirect_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandShakingAck::set_has_redirect_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HandShakingAck::clear_has_redirect_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HandShakingAck::clear_redirect_to() {
  if (redirect_to_ != NULL) redirect_to_->::camp::protocols::common::Endpoint::Clear();
  clear_has_redirect_to();
}
inline const ::camp::protocols::common::Endpoint& HandShakingAck::redirect_to() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return redirect_to_ != NULL ? *redirect_to_ : *default_instance().redirect_to_;
#else
  return redirect_to_ != NULL ? *redirect_to_ : *default_instance_->redirect_to_;
#endif
}
inline ::camp::protocols::common::Endpoint* HandShakingAck::mutable_redirect_to() {
  set_has_redirect_to();
  if (redirect_to_ == NULL) redirect_to_ = new ::camp::protocols::common::Endpoint;
  return redirect_to_;
}
inline ::camp::protocols::common::Endpoint* HandShakingAck::release_redirect_to() {
  clear_has_redirect_to();
  ::camp::protocols::common::Endpoint* temp = redirect_to_;
  redirect_to_ = NULL;
  return temp;
}
inline void HandShakingAck::set_allocated_redirect_to(::camp::protocols::common::Endpoint* redirect_to) {
  delete redirect_to_;
  redirect_to_ = redirect_to;
  if (redirect_to) {
    set_has_redirect_to();
  } else {
    clear_has_redirect_to();
  }
}

// -------------------------------------------------------------------

// LoginOrCreateAccountReq

// required string auth_token = 1;
inline bool LoginOrCreateAccountReq::has_auth_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginOrCreateAccountReq::set_has_auth_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginOrCreateAccountReq::clear_has_auth_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginOrCreateAccountReq::clear_auth_token() {
  if (auth_token_ != &::google::protobuf::internal::kEmptyString) {
    auth_token_->clear();
  }
  clear_has_auth_token();
}
inline const ::std::string& LoginOrCreateAccountReq::auth_token() const {
  return *auth_token_;
}
inline void LoginOrCreateAccountReq::set_auth_token(const ::std::string& value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void LoginOrCreateAccountReq::set_auth_token(const char* value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void LoginOrCreateAccountReq::set_auth_token(const char* value, size_t size) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginOrCreateAccountReq::mutable_auth_token() {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    auth_token_ = new ::std::string;
  }
  return auth_token_;
}
inline ::std::string* LoginOrCreateAccountReq::release_auth_token() {
  clear_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_token_;
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginOrCreateAccountReq::set_allocated_auth_token(::std::string* auth_token) {
  if (auth_token_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_token_;
  }
  if (auth_token) {
    set_has_auth_token();
    auth_token_ = auth_token;
  } else {
    clear_has_auth_token();
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginOrCreateAccountAck

// optional .camp.protocols.player.LoginOrCreateAccountAck.AckError error = 1 [default = NO_ERROR];
inline bool LoginOrCreateAccountAck::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginOrCreateAccountAck::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginOrCreateAccountAck::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginOrCreateAccountAck::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::camp::protocols::player::LoginOrCreateAccountAck_AckError LoginOrCreateAccountAck::error() const {
  return static_cast< ::camp::protocols::player::LoginOrCreateAccountAck_AckError >(error_);
}
inline void LoginOrCreateAccountAck::set_error(::camp::protocols::player::LoginOrCreateAccountAck_AckError value) {
  assert(::camp::protocols::player::LoginOrCreateAccountAck_AckError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional string session_key = 2;
inline bool LoginOrCreateAccountAck::has_session_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginOrCreateAccountAck::set_has_session_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginOrCreateAccountAck::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginOrCreateAccountAck::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& LoginOrCreateAccountAck::session_key() const {
  return *session_key_;
}
inline void LoginOrCreateAccountAck::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void LoginOrCreateAccountAck::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
}
inline void LoginOrCreateAccountAck::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginOrCreateAccountAck::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    session_key_ = new ::std::string;
  }
  return session_key_;
}
inline ::std::string* LoginOrCreateAccountAck::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginOrCreateAccountAck::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::kEmptyString) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace player
}  // namespace protocols
}  // namespace camp

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_player_2eproto__INCLUDED
